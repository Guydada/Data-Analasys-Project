---
title: "Global Trends of CO2 Emission and Effects on the Global Hapinnes Index"
subtitle: "Data Analysis Project - Digital Sciences for Hightech"
author:
- "Guy Krothammer, Yarden Katash, Guy Dahan"
output: 
  html_notebook:
    toc: true
    number_section: false
    fig_width: 10
    fig_height: 10
    fig_caption: true
    df_print: kable
    fontsize: 11pt
    theme: united
---

# Introduction

## Background

This project was done as a part of "Data Analysis" course as part of our teams 
studies in Digital Sciences for High-Tech in the University of Tel-Aviv. 
Our team has great interest in using our studies for exploring and in the future maybe even
developing tools for improving the way we treat our planet. Therefore our subject is
CO2 emissions in congestion with the world happinnes index. 

## Goals

1. Find the trends of CO2 emissions in different countries along the years 1700-2017.
2. Find what countries had greater growth in emissions and in which years.
3. Compare the leading countries with the highest recent trends of growth or decreased emission
in correlation with the current and previous UN happines Index. 

# Part 1: Importing Data and Packages

## Packages Import

```{r}
# install and import packages
install.packages("ggchicklet", repos = "https://cinc.rud.is") # for rounded corners 
install.packages("cowplot") #patch plots
install.packages("hrbrthemes", repos = c("https://cinc.rud.is", "https://cloud.r-project.org/")) #beautiful theme
install.packages("waffle", repos = "https://cinc.rud.is") #waffle plot
install.packages("ggalt") #dumbell plot
install.packages("GGally") # correlation matrix
install.packages("Hmisc")# to install the relative weight package
remotes::install_github("martinctc/rwa") # relative weight analys
install.packages("ISLR")
install.packages("skimr")
install.packages("ggcorrplot")
install.packages("ggpubr")


```

```{r}
# import library
library(tidyverse)
library(ggchicklet)
library(cowplot)
library(hrbrthemes)
library(ggalt)
library(GGally)
library(rwa)
library(readr)
library(Hmisc)
library(tibble)
library(dplyr)
library(ISLR)
library(skimr)
library(ggcorrplot)
library(ggpubr)
```
#Actual Code

## Data import

```{r}
happy_index_2005 <- "Data/world-happiness-report-2005-2020.csv" 
happy_index_2021 <- "Data/world-happiness-report-2021.csv"
emission <- "Data/co2_emission.csv" # TODO The headline isn't loaded well for column 4
population <-"Data/population.csv"

df_2005 <- read.csv(happy_index_2005)
df_2021 <- read.csv(happy_index_2021)
df_emiss <- read.csv(emission, col.names = c("Entity", "Code" , "Year", "co2"))
df_pop <- read.csv(population, col.names = c("Entity", "Code" , "Year", "Population"))

as_tibble(df_2005)
as_tibble(df_2021)
as_tibble(df_emiss)
as_tibble(df_pop)
```

As seen in the table above, the main dataset regarding emissions has only 4 features, of which 2 are identical (countries and country code). 


```{r}
summary(df_emiss)
```


# Part 2: Tidying the Data

## 

```{r}

# add dif column
df_emiss <-df_emiss %>% 
  group_by(Entity) %>%
  mutate(Diff = co2 - lag(co2, default = co2[1]))

#filter year up 1950
df_pop_to_merge <- df_pop %>%
  filter(Year > 1949)

df_emiss_to_merge <- df_emiss %>%
  filter(Year > 1949)

#arrange data to merge emission and population 
df_emiss_to_merge$Entity <- as.character(df_emiss_to_merge$Entity)
df_pop_to_merge$Entity <- as.character(df_pop_to_merge$Entity)

df_all <- full_join(df_emiss_to_merge, df_pop_to_merge, by = c('Entity','Year'))

drops <- c("Code.y")
df_all <-df_all[, !(names(df_all) %in% drops)]

names(df_all)[names(df_all) == "Code.x"] <- "Code"

#add column of normalised emission: co2/population by year (avg.ratio)

df_all <- df_all %>%
  mutate(ratio = co2/Population)

### Create dataframe for both 30 years avarage and by countries
names(df_2005)
names(df_2005)[names(df_2005) == "ï..Country.name"] <- "Entity"

df_2017 <- df_2005 %>%
  filter(year == 2017)%>%
  select(c(Life.Ladder, Entity))

df_last_30 <- df_all %>%
  filter(Year >= 1987) %>%
  na.omit()

agg1 <- aggregate(df_last_30[,c('ratio', 'Population', 'co2')], list(df_last_30$Entity), mean) %>%
  set_names(nm=c('Entity', 'avg.ratio', 'avg.Population', 'avg.co2'))

agg2 <- aggregate(df_last_30[,c('Diff')], list(df_last_30$Entity), sum ) %>%
  set_names(nm=c('Entity', 'sum.dif'))
agg2

df_2017$Entity <- as.character(df_2017$Entity)
agg1$Entity <- as.character(agg1$Entity)
agg2$Entity <- as.character(agg2$Entity)

df_merge <- full_join(agg1, df_2017, by = c('Entity')) %>%
  full_join(agg2) %>%
  na.omit() # TODO check why 20 countries were removed
```

Now we creat two main dataset which we will worke with:
1. "df_merge" which include avg of population, co2 and ratio in the last 30 years, the sum diffrent in co2 emission this period and the life-ladder in 2017.

2. "df_all" which include all data per country per year from 1950 til 2017. 


```{r}
summary(df_merge)
```
```{r}
summary(df_all)
```

```{r}

skim(df_merge)

```

# Part 3: Proccesing of the Data

## Visualisation 

### 3.1 Single Country Emission Graph

```{r}
#TODO add dropbox to choose which country is shown (by HTML CODE)

df = filter(df_emiss, Entity == "United Kingdom")
g <- ggplot(data = df, aes(x = Year, y = co2, group = Entity) ) + 
    geom_line()
    
g <- g + labs(title = "United Kingdom Emissions in metric tons of CO2 by Years")
g
```

### 3.2 Happinness Trends in Single Country 

```{r}
#TODO maybe drop this later

#colnames(df_2005)
#names(df_2005)[1] <- "Entity"

df = filter(df_2005, Entity == "United Kingdom")
g <- ggplot(data = df, aes(x = year, y = Life.Ladder, group = Entity)) + 
    geom_line()
    
g <- g + labs(title = "Contries Hapinness by Years")
g

```

### 3.3


```{r}

g <- ggplot(data = df, aes(x = year, y = Life.Ladder, group = Entity)) + 
    geom_line()
    
g <- g + labs(title = "Contries Hapinness by Years")
g
```
### Year-on-year change in CO₂ for Top 10 Countries

```{r}

top_emiss_2017 <- df_emiss %>%
  filter(Year == 2017) %>%
  filter(Code != '') %>%
  filter(Entity != "World") %>%
  top_n( 10, co2) %>%
  arrange(desc(co2)) %>%
  head(10)
  
top_countries = top_emiss_2017$Entity
```

```{r}
g <- ggplot(data = df_emiss[df_emiss$Entity %in% top_countries, ] 
                          , aes(x = Year, y = co2, group = Entity)) + 
    geom_line() +
    labs(title = "Top 10 Countries by CO2 Emissions") + 
    geom_line(aes(col = Entity))
g

# ?? can remove
#df_emiss[df_emiss$Entity %in% top_countries, ] 
```
```{r}
g <- ggplot(data = df_all[df_all$Entity %in% top_countries, ] 
                          , aes(x = Year, y = ratio, group = Entity)) + 
    geom_line(aes(col = Entity)) + 
    labs(title = "Top 10 Countries by CO2 Emissions to population ratio")
g
```
```{r}
# TODO add density by years for top 10 countries
```

```{r}
# TODO add boxplot for top 10 diff by year
```

```{r}

top_10_happiness <- df_merge %>%
  filter(rank(desc(Life.Ladder))<=10)


g <- ggplot(data = df_emiss[df_emiss$Entity %in% top_10_happiness$Entity, ] 
                          , aes(x = Year, y = co2, group = Entity)) + 
    geom_line() +
    labs(title = "Top 10 happiness Countries by CO2 Emissions") + 
    geom_line(aes(col = Entity))
g
```



## Modelling

Our suggestions:
1. There is correlation between the total trend and current happiness index
2. There is correlation between current emission normalised by population to current happiness index


 


```{r}

```
```{r}


```
```{r}
g <- ggplot(data = df_merge, aes(x = avg.ratio, y = Life.Ladder)) + 
    geom_point() + 
    labs(title = "Scatter plot of avg ratio vs Happiness Index")
g
```

```{r}
df <- subset(df_merge, Entity != "China" & Entity != "India" )

g <- ggplot(data = df, aes(x = Life.Ladder , y = sum.dif)) + 
    geom_point() + 
    labs(title = "Scatter plot of sum.dif vs Happiness Index (without China&India)")
g
```

 # Modelling
 
```{r}
linearmod  <- lm(Life.Ladder ~ avg.ratio, data=df_merge)

summary(linearmod)

confint(linearmod, level=0.95)
plot(fitted(linearmod),residuals(linearmod))


g <- ggplot(df_merge, aes(x = avg.ratio, y = Life.Ladder)) +
  geom_point() + theme_bw() +
  stat_smooth(method = "lm")
g


```

```{r}

numeric_tidy <- df_merge[-1]

corr_data <- cor(numeric_tidy)

g <- ggcorrplot(corr_data, hc.order = TRUE, type = "upper",
   outline.col = "white",
   ggtheme = ggplot2::theme_gray,
   colors = c("darkolivegreen2", "white", "darkolivegreen"))
g

```
```{r}
gmod  <- lm(Life.Ladder ~ log(avg.ratio), data=df_merge)

summary(gmod)
#plot x vs. y
g <- ggplot( df_merge, aes(x=log(avg.ratio), y=Life.Ladder)) +
  geom_point() +
  geom_smooth(method = "glm", 
    method.args = list(family = "binomial"), 
    se = FALSE)
g
```
# TODO re-organize, add ANIMATED/ MORE BEAUTIFULL GRPAHS
# Add text what we need to understand and explain
# Conclusions: present 

```{r}
#multiple regression
multi <- lm(Life.Ladder ~ avg.ratio + sum.dif + avg.co2 , data=df_merge)
summary(multi)

```
Now let’s say we want to compare the differences between the top 10 happiness countries avg.ratio is higher then other countries. In this case, we have two unrelated (i.e., independent or unpaired) groups of samples. Therefore, it’s possible to use an independent t-test to evaluate whether the means are different. 


our research questions is:
the mean of top 10 happiness (mA) is greather than the mean of other countries (mB)?

H0:mA≥mB

Ha:mA<mB (less)


```{r}
# Create a data frame
T_data <- df_merge %>%
  select(Entity, avg.ratio,) %>%
  mutate(group = ifelse(Entity %in% top_10_happiness$Entity, "Top_10", "Other"))


ggboxplot(T_data, x = "group", y = "avg.ratio", 
          color = "group", palette = c("#00AFBB", "#E7B800"),
        ylab = "avg.ratio", xlab = "Groups")  
```

```{r}
#Do the two group have the same variances?
#We’ll use F-test to test for homogeneity in variances. 

res.ftest <- var.test(avg.ratio ~ group, data = T_data)
res.ftest

```
The p-value of F-test is p = 0.03252. It’s no greater than the significance level alpha = 0.05. In conclusion, there is  significant difference between the variances of the two sets of data. Therefore, we use the t-test and assume ther is no equality of the two variances.

```{r}

# Compute t-test
res <- t.test(avg.ratio ~ group, data = T_data, var.equal = FALSE, alternative = "less")
res

```


```{r}

