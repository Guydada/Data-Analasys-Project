---
title: "Global Trends of CO2 Emission and Effects on the Global Hapinnes Index"
author: "Guy Krothammer, Yarden Katash, Guy Dahan"
subtitle: Data Analysis Project - Digital Sciences for Hightech
output:
  html_document:
    toc: yes
    df_print: paged
  html_notebook:
    toc: yes
    number_section: no
    df_print: kable
    fontsize: 11pt
    theme: united
    code_folding: hide
editor_options:
  chunk_output_type: inline
---

# Introduction

## Background

This project was done as a part of "Data Analysis" course as part of our teams 
studies in Digital Sciences for High-Tech in the University of Tel-Aviv. 
Our team has great interest in using our studies for exploring and in the future maybe even
developing tools for improving the way we treat our planet. Therefore our subject is
CO2 emissions in congestion with the world happiness index. 

## Goals

1. Find the trends of CO2 emissions in different countries along the years 1700-2017.
2. Find what countries had greater growth in emissions and in which years.
3. Compare the leading countries with the highest recent trends of growth or decreased emission
in correlation with the current and previous UN happiness Index. 

# Part 1: Importing Data and Packages

```{r, include=FALSE}
knitr::opts_chunk$set(fig.width=600, fig.height=400, fig.align = "center", warning = FALSE, message = FALSE) 
```

```{r, include=FALSE}
# install and import packages

install.packages(c("cowplot", "ggalt", "ggalt", "GGally", "Hmisc", "ISLR", "skimr", "ggcorrplot", "ggpubr", "DiagrammeR", "xts", "countrycode", "countrycode", "shiny"))

remotes::install_github("hrbrmstr/streamgraph")
remotes::install_github("martinctc/rwa") # r
install.packages("waffle", repos = "https://cinc.rud.is") #waffle plot
install.packages("ggchicklet", repos = "https://cinc.rud.is") # for rounded corners 
```

```{r, include=FALSE}
# import library
library(tidyverse)
library(ggchicklet)
library(cowplot)
library(hrbrthemes)
library(ggalt)
library(GGally)
library(rwa)
library(readr)
library(Hmisc)
library(tibble)
library(dplyr)
library(ISLR)
library(skimr)
library(ggcorrplot)
library(ggpubr)
library(xts)
library(countrycode)
library(plotly)
library(shiny)
library(streamgraph)
```


## Data import

```{r, results='hide'}
happy_index_2005 <- "Data/world-happiness-report-2005-2020.csv" 
happy_index_2021 <- "Data/world-happiness-report-2021.csv"
emission <- "Data/co2_emission.csv"
population <-"Data/population.csv"

df_2005 <- read.csv(happy_index_2005)
df_2021 <- read.csv(happy_index_2021)
df_emiss <- read.csv(emission, col.names = c("Entity", "Code" , "Year", "co2"))
df_pop <- read.csv(population, col.names = c("Entity", "Code" , "Year", "Population"))
```

The first Data consists of the UN happiness index for the years 2005-2017.

```{r, collapse=TRUE}
as_tibble(df_2005)
```
The second data is the happiness index report for 2021.

```{r, collapse=TRUE}
as_tibble(df_2021)
```
The third data contains CO2 emissions from around 1700 up until 2017, by countries and continents.

```{r, collapse=TRUE}
as_tibble(df_emiss)
```
The final data is a list of population sizes by countries for about the same years as the CO2 data.

```{r, collapse=TRUE}
as_tibble(df_pop)
```

As seen in the table above, the main dataset regarding emissions has only 4 features, of which 2 are identical (countries and country code). We will now examine the summary of it's characteristics:

```{r}
summary(df_emiss)
```
As seen above, we can see the minimal year, minimal amount of CO2 emissions and same for mean and max values. 
We also learn about the size of the data, around ~21k rows. 

# Part 2: Tidying the Data

## Tidying Functions

```{r, echo=FALSE}

# add "dif" column

df_emiss <-df_emiss %>% 
  group_by(Entity) %>%
  mutate(Diff = co2 - lag(co2, default = co2[1]))

#filter year up 1950

df_pop_to_merge <- df_pop %>%
  filter(Year > 1949)

df_emiss_to_merge <- df_emiss %>%
  filter(Year > 1949)

#arrange data to merge emission and population 

df_emiss_to_merge$Entity <- as.character(df_emiss_to_merge$Entity)
df_pop_to_merge$Entity <- as.character(df_pop_to_merge$Entity)

df_all <- full_join(df_emiss_to_merge, df_pop_to_merge, by = c('Entity','Year'))

drops <- c("Code.y")
df_all <-df_all[, !(names(df_all) %in% drops)]

names(df_all)[names(df_all) == "Code.x"] <- "Code"

#add column of normalized emission: co2/population by year (avg.ratio)

df_all <- df_all %>%
  mutate(ratio = co2/Population)

### Create dataframe for both 30 years average and by countries

names(df_2005)
names(df_2005)[names(df_2005) == "ï..Country.name"] <- "Entity"

df_2017 <- df_2005 %>%
  filter(year == 2017)%>%
  select(c(Life.Ladder, Entity))

df_last_30 <- df_all %>%
  filter(Year >= 1987) %>%
  na.omit()

agg1 <- aggregate(df_last_30[,c('ratio', 'Population', 'co2')], list(df_last_30$Entity), mean) %>%
  set_names(nm=c('Entity', 'avg.ratio', 'avg.Population', 'avg.co2'))

agg2 <- aggregate(df_last_30[,c('Diff')], list(df_last_30$Entity), sum ) %>%
  set_names(nm=c('Entity', 'sum.dif'))
agg2

df_2017$Entity <- as.character(df_2017$Entity)
agg1$Entity <- as.character(agg1$Entity)
agg2$Entity <- as.character(agg2$Entity)

df_merge <- full_join(agg1, df_2017, by = c('Entity')) %>%
  full_join(agg2) %>%
  na.omit() # TODO check why 20 countries were removed

df_merge
```

We have just created the two main datasets to work with, which includes important features from all of the previous datasets and some features that we have created above:

1. "df_all" which include all data per country per year from 1950 til 2017, introducing some new features:
  * Population, taken from the the population's DF
  * CO2/Population ratio, calculated.
  * "Diff" column, which shows the difference between the previous and the current year emissions for each consecutive year.
  
2. "df_merge", which includes data for each country regarding:
  * The average ratio feature, which is calculated from 1950 to 2017 using the previously explained "ratio" feature. 
  * The difference in co2 emission this period and the life-ladder in 2017.
  * The average population in those years. 
  * The average CO2 emissions.
  * The 2017's "Life.Ladder" - happiness index score. 
  * "Sum.Dif" - summing over the diff feature. 

We also made a choice to limit our data regarding emissions to after 1950. The reason is that the rise in values is almost exponential after the years of WW2. When plotted on a graph, placing values from before and after 1950 they become incomparable.  

The summary for df_merge:

```{r, collapse=TRUE}
summary(df_merge)
```
And for df_all:
```{r, collapse=TRUE}
summary(df_all)
```

```{r, collapse=TRUE}
skim(df_merge) # TODO Mayber remove this ? seems to much
```

# Part 3: Proccesing of the Data

## Visualisation 

### Countries of the World
In this plot the different countries in the data are shown in deeper colors for higher values of emission to population ratio in the year of 2017
```{r, fig.align='center', warning=FALSE, message=FALSE}
d = df_all %>%
  filter(Year==2017)
l <- list(color = toRGB("grey"), width = 0.2)

# specify map projection/options
g <- list(
  showframe = FALSE,
  showcoastlines = FALSE,
  projection = list(type = 'Mercator')
)

p <- plot_geo(d) %>%
  add_trace(
    z = ~ratio, color = ~ratio, colors = 'Reds',
    text = ~Entity, locations = ~Code, marker = list(line = l)
  ) %>%
  colorbar(title = 'CO2/Population', thickness=15) %>%
  layout(
    title = 'World Ratio of CO2/Population',
    geo = g,
    autosize = F
  )
```


```{r, fig.align='center', warning=FALSE, message=FALSE}
p <- ggplotly(p, width = 3000, height = 1500, automargin = TRUE)
p
```


### Countries Emission vs Populatio by Years and continents 

The following plot shows for the years 2000-2017 the amount of CO2 emitted from each country vs it's population. The ratio is shown as well as the size of each dot.
For comfort  of the view, each country is allocated to it's fitting continent and a color. 

```{r, include=FALSE, message=FALSE, warning=FALSE}
d <- df_all %>%
  filter(Year > 2000) %>%
  filter(Entity != 'World')

d_cont<- data.frame(country = c(d$Entity))

d_cont$continent <- countrycode(sourcevar = d_cont[, 'country'],
                            origin = "country.name",
                            destination = "continent")
d$continent <- d_cont$continent

d <- na.omit(d)
```


```{r, message=FALSE, collapse=TRUE, warning=FALSE}
fig <- d %>%
  plot_ly(
    x = ~co2, 
    y = ~Population, 
    size = ~ratio,
    frame = ~Year, 
    text = ~Entity, 
    color = ~continent,
    type = 'scatter',
    mode = 'markers',
    height = 500,
    width = 900,
    automargin = TRUE 
  )

fig <- fig %>% layout(
      title = "Yearly CO2 Emissions by Countries vs Population",
      xaxis = list(
      type = "log"
      # autosize = F
    )
  )

fig
```

### Commulative Emissions by Countries Over the Years 1950-2017

```{r, message=FALSE}
# d <- df_all[ , c("Entity", "Year", "Population")]
d <- df_all %>%
  filter(Entity != "World") %>%
  filter(co2 != 0)
d
pp <- streamgraph(d, key="Entity",
                  order = "asis",
                  value="co2", 
                  date="Year",
                  offset="zero",
                  sort="co2"
                  ) %>%
  sg_axis_y(tick_format = "e")  %>%
  sg_legend(show=TRUE, label="Country: ") %>%
  sg_title("CO2 Emissions by Years and Countries, 1950-2017")

pp


```
### Commulative Happinness Trends in Single Country 

```{r}
pp <- streamgraph(df_2005, key = "Entity",
                  # order = "reverse",
                  value="Life.Ladder", 
                  date="year"
                  # offset="zero",
                  ) %>%
  sg_fill_brewer("Blues") %>%
  sg_legend(show=TRUE, label="Country: ") %>%
  sg_title("Happiness Index by Years and Countries, 1950-2017") 
  

pp
# g <- ggplot(data = df_2005, aes(x = year, y = Life.Ladder, group = Entity)) + 
#     geom_line() + 
#     geom_line(color="#69b3a2") +
#     theme_ipsum()
#     
# g <- g + labs(title = "Contries Hapinness by Years")
# g <- ggplotly(g)
# g

```

### Yearly in CO2 Emissions for Top 10 Polluting Countries

```{r}
top_emiss_2017 <- df_emiss %>%
  filter(Year == 2017) %>%
  filter(Code != '') %>%
  filter(Entity != "World") %>%
  top_n( 10, co2) %>%
  arrange(desc(co2)) %>%
  head(10)
  
top_countries = top_emiss_2017$Entity
```

```{r}
g <- ggplot(data = df_emiss[df_emiss$Entity %in% top_countries, ] 
                          , aes(x = Year, y = co2, group = Entity)) + 
    geom_line() +
    labs(title = "Top 10 Countries by CO2 Emissions") + 
    geom_line(aes(col = Entity)) +
    theme_ipsum()
g <- ggplotly(g, height = 500,
    width = 900,
    automargin = TRUE)
g
```


```{r}
g <- ggplot(data = df_all[df_all$Entity %in% top_countries, ] 
                          , aes(x = Year, y = ratio, group = Entity)) + 
    geom_line(aes(col = Entity)) + 
    labs(title = "Top 10 Countries by CO2 Emissions to Population ratio") +
    theme_ipsum()

g <- ggplotly(g, height = 500,
    width = 900,
    automargin = TRUE)
g

```
### Boxplot for top 10 Countries 

```{r, collapse=TRUE, message=FALSE, echo=TRUE, warning=FALSE}

d <- df_all[df_all$Entity %in% top_countries, ] 
fig <- plot_ly(d,
               x = ~Entity,
               y = ~Diff,
               type = "box",
               color = ~Year,
               height = 500,
                width = 900,
                automargin = TRUE)

fig <- fig %>%  layout(
  title = "Difference in Emission for Top 10 Polluting Countries",
  boxmode = "group")
fig
  
```
### Top 10 Happiest countries Emmissions by Years

```{r, collapse=TRUE}

top_10_happiness <- df_merge %>%
  filter(rank(desc(Life.Ladder))<=10)

g <- ggplot(data = df_emiss[df_emiss$Entity %in% top_10_happiness$Entity, ] 
                          , aes(x = Year, y = co2, group = Entity)) + 
    geom_line() +
    labs(title = "Top 10 happiness Countries by CO2 Emissions") + 
    theme_ipsum() +
    geom_line(aes(col = Entity))
g <- ggplotly(g, height = 500,
    width = 900,
    automargin = TRUE)
g
```
In this section we are going to suggest two types of correlation based on our exploration of the data:

1. There is correlation between the total trend of emissions and the current happiness index.
2. There is correlation between current emission normalized by the population to the current happiness index.

```{r, collapse=TRUE}
g <- ggplot(data = df_merge, aes(x = avg.ratio, y = Life.Ladder)) + 
    geom_point(aes(colour = Entity)) + 
    labs(title = "Average Ratio vs Happiness Index") +
    theme_ipsum() 
g <- ggplotly(g, height = 500,
    width = 900,
    automargin = TRUE)
g
```

In the following plot we have removed china and India because they are sort of "outliers" in a sense that they have displayed much larger grow in emissions compared to other countries, therefore making it very hard to disply on the same plot. 

```{r, collapse=TRUE}
df <- subset(df_merge, Entity != "China" & Entity != "India" )

g <- ggplot(data = df, aes(x = Life.Ladder , y = sum.dif)) + 
    geom_point(aes(colour = Entity)) + 
    labs(title = "Sum of Emissions Difference vs 2017 Happiness Index (China, India ex.)") +
    theme_ipsum()
g <- ggplotly(g, height = 500,
    width = 900,
    automargin = TRUE)
g
```

 # Part 4: Modeling
 
 We are now going to introduce the linear model:
 
```{r, collapse=TRUE}
linearmod  <- lm(Life.Ladder ~ avg.ratio, data=df_merge)

summary(linearmod)
```


```{r, collapse=TRUE, warning=FALSE, message=FALSE}
confint(linearmod, level=0.95)
p <- plot_ly(
  x = fitted(linearmod),
  y = residuals(linearmod),
  height = 500,
    width = 900,
    automargin = TRUE)

p<- p %>% layout(
  title = "Residual plot for the Linear Model",
  autosize = T,
  yaxis = list(title = 'Residuals'),
  xaxis = list(title = 'Fitted Linear Model')
  
)

p
```


```{r, collapse=TRUE}
g <- ggplot(df_merge, aes(x = avg.ratio, y = Life.Ladder)) +
  geom_point(aes(colour = Entity)) + 
  theme_bw() +
  stat_smooth(method = "lm") + 
  labs(title = "Linear Modelling Happiness Index and Average Ratio")
g <- ggplotly(g, height = 500,
    width = 900,
    automargin = TRUE)
g


```

```{r, collapse = TRUE}

numeric_tidy <- df_merge[-1]

corr_data <- cor(numeric_tidy)

g <- ggcorrplot(corr_data, hc.order = TRUE, type = "lower",
   outline.col = "white") +
  labs(title = "Correlation Matrix") +
  theme_ipsum()
   # colors = c("darkolivegreen2", "white", "darkolivegreen"))

ax <- list(
  title = "",
  showgrid = FALSE)
  
g <- ggplotly(g, height = 500,
    width = 900,
    automargin = TRUE) %>%
  layout(xaxis=ax, yaxis=ax)
g


```
The following section presents another model and it's summary:

```{r, collapse=TRUE, warning=FALSE}
gmod  <- lm(Life.Ladder ~ log(avg.ratio), data=df_merge)

summary(gmod)
```


```{r, collapse=TRUE, warning=FALSE}
#plot x

p <- qplot(x = avg.ratio, Life.Ladder, data=df_merge)
p <- p + geom_smooth(method = "glm", formula = y~log(x), family = binomial(link = 'log')) +
  geom_point(aes(colour=Entity)) +
  theme_ipsum() +
  labs(title = "Linear Regression Model - Average Ratio to Life Ladder Score")
p <- ggplotly(p, height = 500,
    width = 900,
    automargin = TRUE)
p
```
On this model, We can see a week correlation, but an existing one to the logistic regression. Interestingly enough, The "happiest" countries seem to have a higher ratio of CO2 emissions as well. Also worth mentioning from this plot:
* The US is located far right on this map, meaning it's emitting a lot of CO2 in proportion to it's population, but it is pretty high on the happiness index as well. 
* Kuwait, being the leader of this unfortunate characteristic, also has a pretty decent Life Ladder score. 
*

# Add text what we need to understand and explain
# Conclusions: present 

```{r, collapse=TRUE}
#multiple regression
ex_list <- c("China", "India", "United States")

d <- df_merge[(!(df_merge$Entity %in% ex_list)),]

x <- d$avg.ratio + d$sum.dif + d$avg.co2

multi <- lm(Life.Ladder ~ x, data=d)
p <- qplot(x, Life.Ladder,  data=d)
p <- p + 
  geom_smooth(method = "lm",
                     formula = y~x, family = binomial(link = 'log')) +
  geom_point(aes(colour=Entity)) +
  theme_ipsum() +
  labs(title = "Linear Regression Model -Multiple Variables to Life Ladder Score")

fig <- ggplotly(p, height = 500,
    width = 900,
    automargin = TRUE)

fig

```
Now let’s say we want to compare the differences between the top 10 happiness countries avg.ratio is higher then other countries. In this case, we have two unrelated (i.e., independent or unpaired) groups of samples. Therefore, it’s possible to use an independent t-test to evaluate whether the means are different. 

mA - Weighted average of the 10 most happiest countries.
mB - Weighted average of the rest of the countries.

Our research questions:


## Is the mean of top 10 happiness (mA) is greater than the mean of other countries (mB)? // Yarden - I fixed the sentence

Is the weighted average of the 10 happiest countries (mA) greater than the weighted average of the other countries (mB)?

H0:mA≥mB  - The null hypothesis

Ha:mA<mB (less) - The alternative hypothesis


```{r}
# Create a data frame
T_data <- df_merge %>%
  select(Entity, avg.ratio,) %>%
  mutate(group = ifelse(Entity %in% top_10_happiness$Entity, "Top 10 Contries", "Other Countries")) 
  

## TODO Yarden - Need to add to T_data a column of Life.Ladder

## TODO make a graph that shows the difference of Life Ladder and avg.ratio by groups "top_10" and "others". 

g <- ggboxplot(T_data, x = "group", y = "avg.ratio", 
          color = "group", palette = c("#00AFBB", "#E7B800"),
        ylab = "avg. ratio", xlab = "Group") +
  theme_ipsum() +
  labs(title = "Average Ratio Compared - Top 10 Countries vs Other Countries")

g <- ggplotly(g, height = 500,
    width = 900,
    automargin = TRUE)
g


```

```{r}
#Do the two group have the same variances?
#We’ll use F-test to test for homogeneity in variances. 

res.ftest <- var.test(avg.ratio ~ group, data = T_data)
res.ftest

```
The p-value of the F-test is p = 0.03252. It is lower than the significance level alpha = 0.05. In conclusion, there is  a significant difference between the variances of the two data sets. Therefore, we used the T-test and assumed that the variances are not equal - according to case 1 of hypothesis testing.

```{r}

# Compute t-test
res <- t.test(avg.ratio ~ group, data = T_data, var.equal = FALSE, alternative = "less")
res

```